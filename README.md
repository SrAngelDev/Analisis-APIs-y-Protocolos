Informe Técnico: Análisis Comparativo de Paradigmas de API — REST, GraphQL y WebSocket: ¿Cuál elegir y por qué?1. Introducción a los Paradigmas de Comunicación API1.1. El Rol Crítico de las APIs en la Arquitectura Web ModernaEn el desarrollo de software contemporáneo, la arquitectura de comunicación entre el cliente y el servidor no es un mero detalle técnico, sino el pilar fundamental sobre el que se construyen aplicaciones robustas, escalables y eficientes. Una Interfaz de Programación de Aplicaciones (API, por sus siglas en inglés) actúa como el contrato que define cómo interactúan los distintos componentes de un sistema. La elección de la arquitectura API correcta es, por tanto, una de las decisiones más críticas en el ciclo de vida de un proyecto, con profundas implicaciones en múltiples facetas del negocio y la tecnología.1Desde una perspectiva técnica, una arquitectura bien planificada organiza los componentes de la aplicación de manera lógica, facilitando el desarrollo, el mantenimiento y la evolución del código base.2 Permite una clara separación de responsabilidades, aislando la lógica de negocio en el servidor y la presentación en el cliente. Esta separación no solo mejora la seguridad al no exponer directamente los procesos internos, sino que también permite que los equipos de frontend y backend trabajen de forma paralela e independiente, acelerando el tiempo de salida al mercado.1Más allá de la estructura interna, la arquitectura de comunicación impacta directamente en la experiencia del usuario (UX). Una API eficiente reduce los tiempos de carga y mejora la capacidad de respuesta de la aplicación, factores clave para la retención de usuarios y el incremento de las tasas de conversión.3 Por el contrario, una arquitectura deficiente puede llevar a la frustración del usuario, manifestada en altas tasas de rebote y abandono de la plataforma.4 Adicionalmente, una estructura de API clara y coherente, especialmente en el caso de las APIs públicas, facilita su indexación por parte de los motores de búsqueda, lo que puede mejorar significativamente el posicionamiento orgánico (SEO) de un sitio web.31.2. Contextualización y Objetivos del Análisis ComparativoLas APIs no son un concepto estático; su evolución ha sido un reflejo directo de las cambiantes necesidades de las aplicaciones web. Históricamente, las primeras interfaces eran a nivel de sistema, permitiendo la comunicación entre componentes en una misma máquina.6 Con la llegada de la web distribuida, surgieron protocolos como SOAP (Simple Object Access Protocol), que, aunque potentes, eran a menudo verbosos y complejos debido a su dependencia de XML.7La aparición de REST (Representational State Transfer) en el año 2000 supuso una revolución. Al aprovechar los estándares existentes de la web, principalmente el protocolo HTTP, REST ofreció un enfoque más simple y ligero que se convirtió en el estándar de facto para la construcción de APIs web durante más de una década.6 Sin embargo, la propia evolución de la web comenzó a exponer sus limitaciones.Este cambio se puede entender como una progresiva transferencia de poder y complejidad desde el servidor hacia el cliente. Inicialmente, el servidor dictaba todo, enviando páginas HTML completas. Con el auge de las Single-Page Applications (SPAs) y las aplicaciones móviles, el cliente se volvió más inteligente y demandó solo los datos, no la presentación. REST satisfizo esta necesidad, pero el servidor todavía controlaba la estructura de esos datos a través de sus endpoints de recursos fijos. La explosión de dispositivos móviles, con sus diversas interfaces y restricciones de ancho de banda, hizo que este modelo de "talla única" de REST resultara ineficiente.Fue en este contexto que nacieron paradigmas más modernos. GraphQL, desarrollado por Facebook en 2012 y liberado como código abierto en 2015, surgió para resolver directamente el problema de la ineficiencia en la obtención de datos, transfiriendo al cliente el poder de especificar exactamente qué datos necesita.6 Casi simultáneamente, la necesidad de interactividad en tiempo real en aplicaciones como chats, juegos y notificaciones en vivo superó las limitaciones del modelo de solicitud-respuesta de HTTP. WebSocket, estandarizado en 2011, respondió a esta demanda creando un canal de comunicación persistente y bidireccional, nivelando el campo de juego entre cliente y servidor.11El objetivo de este informe es realizar un análisis técnico profundo y comparativo de estos tres paradigmas dominantes: REST, GraphQL y WebSocket. Se desgranarán sus filosofías de diseño, protocolos subyacentes, estructuras de comunicación y mecanismos de gestión de errores. Al finalizar, el lector estará capacitado para tomar decisiones arquitectónicas informadas, justificando técnicamente cuál de estas tecnologías es la más adecuada para los distintos tipos de proyectos que se encuentran en el desarrollo web profesional.2. Análisis Detallado por Tecnología2.1. REST (Representational State Transfer): El Paradigma Orientado a Recursos2.1.1. Filosofía de Diseño: Recursos, Cliente-Servidor y Ausencia de EstadoREST no es un protocolo ni un estándar, sino un estilo arquitectónico para sistemas distribuidos, definido por Roy Fielding en su tesis doctoral del año 2000.13 Su filosofía se centra en un concepto clave: el recurso. En una arquitectura REST, cualquier entidad de información (un usuario, un producto, un artículo de blog) es un recurso que puede ser identificado de manera única a través de un Identificador Uniforme de Recursos (URI).15Para que una API sea considerada "RESTful", debe adherirse a un conjunto de seis restricciones arquitectónicas que guían su diseño y garantizan propiedades deseables como la escalabilidad, la simplicidad y la fiabilidad 16:Separación Cliente-Servidor: El cliente (quien consume la API) y el servidor (quien expone los recursos) son componentes completamente independientes. El cliente solo necesita conocer la URI del recurso que desea manipular. Esta separación permite que ambos sistemas evolucionen de forma autónoma; por ejemplo, el backend puede cambiar su base de datos o lenguaje de programación sin afectar al cliente, siempre que el contrato de la API (las URIs y la estructura de las representaciones) se mantenga.15Sin Estado (Stateless): La comunicación entre cliente y servidor es sin estado. Esto significa que cada solicitud enviada desde el cliente al servidor debe contener toda la información necesaria para que el servidor la comprenda y la procese. El servidor no almacena ningún contexto de sesión del cliente entre peticiones. Esta restricción es crucial para la escalabilidad, ya que cualquier servidor puede atender cualquier petición, simplificando enormemente el balanceo de carga.15Interfaz Uniforme: Esta es la restricción central de REST y se logra a través de cuatro sub-restricciones. Impone una forma estandarizada y consistente de interactuar con los recursos, independientemente de su tipo.16Identificación de recursos: Cada recurso se identifica unívocamente mediante una URI (ej. /users/123).Manipulación de recursos a través de representaciones: El cliente interactúa con una representación del recurso (generalmente en formato JSON o XML), no con el recurso en sí. Esta representación contiene los datos y metadatos necesarios.Mensajes autodescriptivos: Cada mensaje (petición o respuesta) contiene suficiente información para describir cómo procesarlo. Por ejemplo, una respuesta puede usar cabeceras HTTP como Content-Type para indicar que el cuerpo es application/json.Hipermedia como el Motor del Estado de la Aplicación (HATEOAS): Las respuestas del servidor deben incluir enlaces (hipervínculos) que permitan al cliente descubrir otras acciones y recursos disponibles de forma dinámica.Cacheabilidad: Las respuestas del servidor deben indicar explícitamente si son cacheables o no. El almacenamiento en caché, ya sea en el cliente o en intermediarios (como una CDN), mejora drásticamente el rendimiento y reduce la carga del servidor al evitar peticiones redundantes.16Sistema en Capas: La arquitectura puede estar compuesta por múltiples capas (proxies, balanceadores de carga, gateways). El cliente no necesita saber si se está comunicando directamente con el servidor final o con un intermediario. Esto permite mejorar la seguridad, el rendimiento y la escalabilidad del sistema sin afectar al cliente.16Código bajo demanda (Opcional): El servidor puede extender temporalmente la funcionalidad del cliente transfiriéndole código ejecutable, como scripts de JavaScript. Este es el único principio opcional.162.1.2. Protocolo Base: El Rol Fundamental de HTTP/1.1Aunque REST es teóricamente agnóstico al protocolo, en la práctica está intrínsecamente ligado al Protocolo de Transferencia de Hipertexto (HTTP), específicamente en su versión 1.1.17 REST no reinventa la rueda; en su lugar, aprovecha de manera sistemática y semántica las características ya existentes en HTTP para cumplir con sus principios arquitectónicos. Los verbos HTTP definen las acciones, las URIs identifican los recursos, las cabeceras HTTP transportan metadatos y los códigos de estado HTTP comunican el resultado de las operaciones.13 Esta simbiosis es tan fuerte que, en el desarrollo web, hablar de una API RESTful es casi sinónimo de hablar de una API sobre HTTP.2.1.3. Operaciones y Sintaxis: El Uso Semántico de los Verbos HTTPEn una API RESTful, las operaciones sobre los recursos no se definen en la URI, sino que se mapean directamente a los verbos (o métodos) HTTP. Este uso semántico de los verbos es fundamental para la interfaz uniforme. Las operaciones CRUD (Crear, Leer, Actualizar, Borrar) se corresponden con los siguientes métodos HTTP 22:GET: Se utiliza para recuperar la representación de un recurso o una colección de recursos. Es una operación segura (no debe modificar el estado del servidor) e idempotente (múltiples peticiones idénticas producen el mismo resultado). Por ejemplo, GET /users/123 recupera el usuario con ID 123.POST: Se utiliza para crear un nuevo recurso subordinado dentro de una colección. No es idempotente, ya que ejecutar la misma petición POST varias veces creará múltiples recursos nuevos. Por ejemplo, POST /users crea un nuevo usuario con los datos enviados en el cuerpo de la petición.PUT: Se utiliza para reemplazar completamente un recurso existente con una nueva representación. Es idempotente, ya que actualizar un recurso con los mismos datos varias veces resulta en el mismo estado final. Por ejemplo, PUT /users/123 actualiza toda la información del usuario 123.PATCH: Se utiliza para aplicar una actualización parcial a un recurso. A diferencia de PUT, solo se envían los campos que se desean modificar. Su idempotencia depende de la naturaleza de la operación. Por ejemplo, PATCH /users/123 podría usarse para cambiar únicamente el email del usuario.DELETE: Se utiliza para eliminar un recurso. Es idempotente, ya que eliminar un recurso que ya no existe no produce un nuevo cambio de estado. Por ejemplo, DELETE /users/123 elimina al usuario con ID 123.MétodoAcciónIdempotenteCuerpo de la solicitudGETObtener un recurso✅ Sí❌ NoPOSTCrear un recurso❌ No✅ SíPUTReemplazar un recurso✅ Sí✅ SíPATCHModificar parcialmente❌ No✅ SíDELETEEliminar un recurso✅ Sí❌ No (en general)2.1.4. Estructura de la Petición: Anatomía de una Llamada RESTful (URI, Endpoint, Payload)Una petición a una API RESTful se compone de varias partes clave que trabajan en conjunto para identificar un recurso y la acción a realizar sobre él 13:URI (Uniform Resource Identifier) / Endpoint: Es la dirección que identifica de manera única al recurso. En REST, se sigue una convención de diseño de URIs jerárquica y basada en sustantivos en plural para las colecciones. Por ejemplo, https://api.example.com/users es el endpoint para la colección de usuarios, y https://api.example.com/users/123/posts es el endpoint para las publicaciones del usuario 123.13Método HTTP: Como se describió anteriormente, es el verbo (GET, POST, etc.) que especifica la acción a realizar.Cabeceras (Headers): Contienen metadatos sobre la petición, como el tipo de contenido que se envía (Content-Type: application/json), el formato de respuesta aceptado (Accept: application/json) o las credenciales de autenticación (Authorization: Bearer <token>).Payload (Cuerpo de la Petición): Para métodos como POST, PUT y PATCH, el cuerpo de la petición contiene la representación de los datos del recurso que se va a crear o modificar, generalmente en formato JSON.22 En una petición POST /users, el payload podría ser: {"name": "Jane Doe", "email": "jane.doe@example.com"}.2.1.5. Gestión de Estado y Errores: Interpretación de los Códigos de Estado HTTPLa gestión de errores en REST es uno de sus puntos fuertes, ya que se apoya en el robusto y estandarizado sistema de códigos de estado HTTP. Cada respuesta del servidor incluye un código que informa al cliente sobre el resultado de su petición, permitiendo un manejo de errores predecible y consistente.25 Estos códigos se agrupan en cinco clases:1xx (Respuestas informativas): La petición fue recibida y el proceso continúa. Son poco comunes en el uso diario de APIs.2xx (Respuestas satisfactorias): La petición fue recibida, entendida y aceptada con éxito.200 OK: Éxito genérico para una petición GET, PUT o PATCH.201 Created: El recurso fue creado exitosamente (respuesta a un POST).204 No Content: La petición fue exitosa pero no hay contenido que devolver (respuesta común a un DELETE).3xx (Redirecciones): Se necesita una acción adicional para completar la petición.301 Moved Permanently: El recurso ha sido movido permanentemente a una nueva URI.4xx (Errores del cliente): La petición contiene una sintaxis incorrecta o no puede ser cumplida.400 Bad Request: La petición del cliente es inválida (ej. JSON malformado).401 Unauthorized: El cliente debe autenticarse para obtener la respuesta solicitada.403 Forbidden: El cliente está autenticado pero no tiene los permisos necesarios para acceder al recurso.404 Not Found: El recurso solicitado no existe en el servidor.409 Conflict: La petición entra en conflicto con el estado actual del recurso (ej. intentar crear un usuario con un email que ya existe).5xx (Errores del servidor): El servidor falló al intentar cumplir una petición aparentemente válida.500 Internal Server Error: Un error genérico e inesperado ocurrió en el servidor.2.1.6. Ventajas y Desventajas TécnicasVentajas:Simplicidad y Familiaridad: Al estar basado en estándares web universales como HTTP y URIs, REST tiene una curva de aprendizaje relativamente baja para los desarrolladores web. Su enfoque es intuitivo y fácil de entender.27Escalabilidad y Fiabilidad: El principio de "sin estado" (stateless) es clave. Al no tener que gestionar sesiones de cliente, los servidores pueden escalar horizontalmente con facilidad. Cualquier servidor de un clúster puede procesar cualquier petición, lo que simplifica el balanceo de carga y aumenta la fiabilidad del sistema.15Flexibilidad e Independencia Tecnológica: La estricta separación entre cliente y servidor permite que cada componente evolucione de forma independiente. El backend puede ser reescrito en un nuevo lenguaje o migrado a una nueva base de datos sin afectar al cliente, siempre que el contrato de la API se respete. Esto también permite la creación de múltiples clientes (web, móvil, iOS, Android) para un único backend.19Desventajas:Over-fetching y Under-fetching: Este es uno de los mayores inconvenientes de REST. Dado que los endpoints devuelven una estructura de datos fija, es común que el cliente reciba más información de la que necesita (over-fetching), malgastando ancho de banda. Alternativamente, puede que un endpoint no devuelva toda la información necesaria, forzando al cliente a realizar múltiples peticiones a otros endpoints (under-fetching).29Múltiples Viajes de Ida y Vuelta (Round-trips): Como consecuencia del under-fetching, para construir una vista compleja que requiere datos de varios recursos relacionados (ej. un perfil de usuario con sus publicaciones y sus seguidores), el cliente debe realizar múltiples peticiones secuenciales a la API. Cada una de estas peticiones introduce latencia, lo que es especialmente perjudicial en redes móviles.31Gestión de la Evolución (Versioning): A medida que una API evoluciona, introducir cambios que rompan la compatibilidad con clientes antiguos es un desafío. La práctica común en REST es el versionado a través de la URI (ej. /api/v1/users, /api/v2/users), lo que puede llevar a una proliferación de versiones que deben ser mantenidas.132.2. GraphQL: El Paradigma Orientado a un Grafo de Datos2.2.1. Filosofía de Diseño: Consultas Flexibles sobre un Esquema TipadoGraphQL es un lenguaje de consulta para APIs y un tiempo de ejecución del lado del servidor para ejecutar esas consultas. A diferencia de REST, no es un estilo arquitectónico, sino una especificación.32 Su filosofía de diseño es fundamentalmente centrada en el producto y en el cliente, nacida de la necesidad de Facebook de construir aplicaciones complejas y eficientes para dispositivos móviles.33La idea central de GraphQL es que se orienta a un Grafo de Datos. En lugar de exponer un conjunto de endpoints de recursos fijos, expone un único "grafo" que representa todos los datos y sus interrelaciones en el dominio de la aplicación. El cliente puede entonces enviar una consulta que navega por este grafo para solicitar una estructura de datos jerárquica y anidada, obteniendo exactamente lo que necesita en una sola petición.33Esta filosofía se sustenta en tres pilares conceptuales 10:Schema (Esquema): Es el corazón de una API GraphQL. El esquema es un contrato fuertemente tipado que define todas las capacidades de la API: los tipos de objetos, los campos que contienen y las operaciones (consultas, mutaciones) que se pueden realizar. Actúa como la "única fuente de la verdad" para la comunicación entre cliente y servidor.10Tipado Fuerte (Strong Typing): Cada elemento en el esquema de GraphQL tiene un tipo definido (escalares como String, Int, o tipos de objetos complejos). Este sistema de tipos permite que las herramientas validen las consultas del cliente antes de ejecutarlas, garantizando que son sintácticamente correctas y que las respuestas tendrán una forma predecible. Esto previene una clase entera de errores en tiempo de ejecución.32Introspección: Una API GraphQL es autodocumentada. El propio esquema puede ser consultado. Un cliente puede enviar una consulta de introspección para preguntar a la API qué tipos soporta, qué campos tiene cada tipo y qué operaciones están disponibles. Esta capacidad es la que alimenta herramientas de desarrollo tan potentes como GraphiQL o Apollo Studio, que proporcionan autocompletado y validación en tiempo real.102.2.2. Protocolo Base: Operando sobre HTTP con un Enfoque DistintoGraphQL es agnóstico al protocolo de transporte.32 Puede funcionar sobre cualquier protocolo que permita un modelo de solicitud-respuesta. Sin embargo, en la práctica, la implementación más común y estandarizada es sobre HTTP.38A diferencia de REST, GraphQL no utiliza las características semánticas de HTTP de la misma manera. No mapea operaciones a diferentes verbos HTTP ni utiliza múltiples URIs para diferentes recursos. Generalmente, todas las operaciones de GraphQL (queries, mutations) se envían a través de peticiones HTTP POST a un único endpoint. Las operaciones de Subscription para datos en tiempo real, sin embargo, suelen requerir un protocolo persistente como WebSockets.322.2.3. Operaciones y Sintaxis: Queries, Mutations y SubscriptionsGraphQL define tres tipos de operaciones principales que un cliente puede ejecutar. La sintaxis es declarativa y jerárquica, reflejando la estructura de la respuesta deseada 40:Query (Consulta): Se utiliza para la lectura de datos. Es la operación por defecto y es conceptualmente análoga a una petición GET en REST. El cliente especifica el objeto raíz que desea consultar y los campos anidados que necesita.Ejemplo: query { user(id: "1") { name email posts { title } } }Mutation (Mutación): Se utiliza para operaciones de escritura de datos (crear, actualizar o eliminar). Es análoga a las peticiones POST, PUT, PATCH y DELETE en REST. Por convención, el nombre de la mutación describe la acción (ej. createUser). Una diferencia clave con las queries es que los campos de una mutación se ejecutan en serie, uno tras otro, para garantizar la consistencia de los datos y evitar condiciones de carrera.33Ejemplo: mutation { createUser(input: {name: "Alex", email: "alex@example.com"}) { id name } }Subscription (Suscripción): Se utiliza para recibir actualizaciones de datos en tiempo real. El cliente se suscribe a un evento en el servidor y, a través de una conexión de larga duración (generalmente sobre WebSockets), el servidor le envía datos cada vez que ese evento ocurre. No tiene un equivalente directo en el modelo REST estándar.40Ejemplo: subscription { newCommentOnPost(postId: "123") { id content author { name } } }2.2.4. Estructura de la Petición: El Endpoint Único y el Poder del PayloadLa estructura de una petición GraphQL es radicalmente diferente a la de REST 38:Endpoint Único: En lugar de tener múltiples endpoints para cada recurso, una API GraphQL expone un único endpoint (por convención, /graphql) para todas sus operaciones.10 Toda la comunicación, ya sea para obtener usuarios, crear publicaciones o actualizar comentarios, se dirige a esta misma URL.Payload (Cuerpo de la Petición): El "cerebro" de la operación reside en el payload de la petición, que es un cuerpo JSON enviado generalmente vía POST. Este payload contiene la consulta GraphQL en sí.38 Su estructura típica incluye:query: Una cadena de texto que contiene el documento GraphQL con la operación (query, mutation o subscription) que se desea ejecutar.operationName: Una cadena opcional que especifica cuál de las operaciones del documento query ejecutar, útil cuando se envían múltiples operaciones en una sola petición.variables: Un objeto JSON opcional que contiene valores dinámicos para los argumentos de la consulta, permitiendo reutilizar la misma estructura de consulta con diferentes datos.2.2.5. Gestión de Estado y Errores: Respuestas 200 OK con Cuerpos de Error DetalladosLa gestión de errores en GraphQL es uno de sus aspectos más distintivos y a menudo un punto de confusión para quienes vienen de REST.45A nivel de protocolo (HTTP): GraphQL no utiliza los códigos de estado HTTP para comunicar errores de lógica de negocio o de validación. Una petición GraphQL, incluso si resulta en un error (por ejemplo, un campo solicitado no existe o el usuario no tiene permisos), casi siempre devolverá un código de estado 200 OK. Los códigos 4xx o 5xx se reservan para errores a nivel de red o servidor, como una petición malformada o un fallo del servidor HTTP en sí.46A nivel de datos (cuerpo de la respuesta): El estado real de la operación se comunica dentro del cuerpo de la respuesta JSON. Una respuesta GraphQL siempre tendrá una estructura predecible. Puede contener hasta tres claves de nivel superior: data, errors y extensions.45data: Contiene el resultado de la consulta si fue exitosa. Si ocurrió un error que impidió resolver un campo, ese campo puede aparecer como null en la respuesta. Es posible recibir datos parciales junto con errores.errors: Es un array que contiene uno o más objetos de error si algo salió mal durante la validación o ejecución de la consulta. Cada objeto de error tiene una estructura estandarizada que incluye:message: Una descripción legible del error.locations: Un array que indica la línea y columna en la consulta original donde ocurrió el error.path: Un array que traza la ruta del campo en la consulta que resultó en el error.extensions: Un objeto opcional para metadatos adicionales, como códigos de error personalizados.2.2.6. Ventajas y Desventajas TécnicasVentajas:Eficiencia de Datos (Sin Over/Under-fetching): Esta es la ventaja principal. El cliente solicita y recibe exactamente los datos que necesita, ni más ni menos, en una única petición. Esto reduce drásticamente el uso de ancho de banda y la latencia, siendo ideal para aplicaciones móviles y de frontend complejas.29Evolución de la API sin Versionado: El esquema puede evolucionar de forma flexible. Se pueden añadir nuevos campos y tipos a la API sin afectar a los clientes existentes. Los campos pueden marcarse como obsoletos (deprecated) para guiar una migración gradual, eliminando la necesidad de mantener múltiples versiones de la API como en REST.35Contrato Fuerte a través del Esquema y Tipado: El esquema actúa como un contrato robusto y autodocumentado entre el cliente y el servidor. El sistema de tipos permite detectar errores en tiempo de desarrollo y habilita un ecosistema de herramientas muy potente que mejora la productividad.34Desventajas:Complejidad en el Caching: El caching a nivel de HTTP, que es una fortaleza de REST, se vuelve más complejo en GraphQL. Dado que la mayoría de las consultas van a un único endpoint vía POST, las estrategias de caché de red (como las de los navegadores o CDNs) no funcionan de la misma manera. El caching debe gestionarse más a nivel de cliente (ej. con librerías como Apollo Client) o con técnicas más avanzadas en el servidor.46Curva de Aprendizaje: Para los equipos acostumbrados a REST, GraphQL introduce nuevos conceptos que deben ser aprendidos: el lenguaje de consulta, el diseño de esquemas, los tipos, los resolvers y el funcionamiento del ecosistema de herramientas. Esto puede suponer una inversión inicial de tiempo y esfuerzo.10Gestión de Errores y Monitorización a Nivel de HTTP: El hecho de que las peticiones con errores de negocio devuelvan un código 200 OK puede complicar el monitoreo y la gestión de errores basados en códigos de estado HTTP. Requiere que las herramientas de monitoreo y los clientes inspeccionen el cuerpo de la respuesta para detectar problemas, en lugar de simplemente verificar el código de estado.462.3. WebSocket: El Paradigma del Canal Persistente2.3.1. Filosofía de Diseño: Comunicación Bidireccional y Full-DuplexA diferencia de REST y GraphQL, que se centran en cómo estructurar y solicitar datos, WebSocket es un protocolo de comunicación.12 Su filosofía de diseño se centra en un único objetivo: establecer un canal de comunicación persistente, bidireccional y full-duplex entre un cliente y un servidor sobre una única conexión TCP.49La clave de su filosofía reside en superar la limitación fundamental del modelo solicitud-respuesta de HTTP. En HTTP, la comunicación siempre es iniciada por el cliente. Con WebSocket, una vez que la conexión está establecida, esta barrera desaparece. Tanto el cliente como el servidor pueden enviar datos en cualquier momento, de forma independiente y asíncrona. Esto lo convierte en la tecnología ideal para aplicaciones que requieren una interacción en tiempo real y de baja latencia.112.3.2. Protocolo Base: Del Handshake HTTP a la Comunicación sobre TCPEl protocolo WebSocket, definido en el RFC 6455, opera directamente sobre TCP (Transmission Control Protocol), lo que garantiza una entrega de datos fiable y ordenada.12Sin embargo, para ser compatible con la infraestructura web existente (proxies, firewalls), la conexión WebSocket se inicia de una manera ingeniosa: a través de un handshake HTTP. El proceso es el siguiente 49:El cliente envía una petición HTTP/1.1 GET estándar al servidor.Esta petición incluye cabeceras especiales, principalmente Upgrade: websocket y Connection: Upgrade, que señalan la intención del cliente de cambiar del protocolo HTTP al protocolo WebSocket.Si el servidor soporta WebSockets y acepta la petición, responde con un código de estado HTTP 101 Switching Protocols.A partir de ese momento, la conexión HTTP se "actualiza" y la misma conexión TCP subyacente se convierte en un canal WebSocket persistente para la comunicación bidireccional.Las URIs de WebSocket utilizan los esquemas ws:// (para conexiones no cifradas, análogo a http://) y wss:// (para conexiones seguras sobre TLS, análogo a https://).122.3.3. Operaciones y Sintaxis: Un Modelo Basado en Eventos y MensajesLa comunicación a través de un canal WebSocket no sigue un paradigma de operaciones como los verbos de REST o las queries de GraphQL. En su lugar, utiliza un modelo asíncrono basado en eventos y mensajes, tanto en el cliente como en el servidor.55En el lado del cliente (por ejemplo, en un navegador), la API de WebSocket expone una interfaz sencilla con los siguientes eventos y métodos principales 56:Eventos:onopen: Se dispara una vez que el handshake ha sido exitoso y la conexión está establecida y lista para usarse.onmessage: Se dispara cada vez que se recibe un mensaje desde el servidor. El objeto del evento contiene los datos (event.data).onerror: Se dispara si ocurre un error en la conexión.onclose: Se dispara cuando la conexión se cierra, ya sea por iniciativa del cliente, del servidor o por un fallo de red.Métodos:send(data): Envía un mensaje al servidor. Los datos pueden ser una cadena de texto o datos binarios (como Blob o ArrayBuffer).close(code, reason): Inicia el cierre de la conexión, enviando opcionalmente un código de cierre y una razón.2.3.4. Estructura de la Petición: Handshake de Actualización y Tramas de DatosLa comunicación WebSocket tiene dos fases estructurales distintas 57:Handshake Inicial: Como se mencionó, es una petición HTTP GET que incluye cabeceras clave para la negociación. La cabecera Sec-WebSocket-Key enviada por el cliente contiene un valor aleatorio. El servidor, para confirmar que entiende el protocolo, utiliza este valor para calcular una respuesta y la envía en la cabecera Sec-WebSocket-Accept. Este mecanismo evita que proxies HTTP mal configurados interfieran con la conexión.58Tramas de Datos (Data Frames): Una vez la conexión está abierta, toda la comunicación posterior se realiza mediante el intercambio de tramas (frames). El protocolo WebSocket define una estructura de trama binaria con una sobrecarga muy baja (mínimo 2 bytes de cabecera). Esto lo hace mucho más eficiente que HTTP para mensajes frecuentes y pequeños. Existen diferentes tipos de tramas 57:Tramas de datos: Pueden ser de tipo text (codificado en UTF-8) o binary. También existen tramas de continuation para mensajes fragmentados.Tramas de control: No transportan datos de la aplicación, sino que gestionan el canal. Las más importantes son ping y pong (para mantener la conexión viva y medir la latencia) y close (para iniciar el cierre ordenado de la conexión).2.3.5. Gestión de Estado y Errores: Códigos de Cierre y el Evento onerrorLa gestión de errores en WebSocket se centra en el estado del canal de comunicación. Los problemas se comunican principalmente a través del cierre de la conexión.62El evento onerror se dispara en el cliente cuando ocurre un error de bajo nivel que no necesariamente cierra la conexión de inmediato, aunque a menudo precede a un evento onclose.El mecanismo principal para comunicar el motivo de un cierre es a través de los códigos de cierre definidos en el RFC 6455. Cuando la conexión se cierra, el evento onclose proporciona un objeto CloseEvent que contiene una propiedad code (un número) y reason (una cadena de texto).62A continuación, se presentan los códigos de cierre estándar más relevantes (1000-1015) 62:CódigoNombreDescripción1000Normal ClosureCierre normal. La conexión ha cumplido su propósito.1001Going AwayUn endpoint se está desconectando (ej. el servidor se apaga o el usuario navega a otra página).1002Protocol ErrorEl endpoint termina la conexión debido a un error de protocolo.1003Unsupported DataEl endpoint termina la conexión porque recibió un tipo de datos que no puede aceptar.1005No Status Received(Reservado) Indica que no se recibió un código de estado, aunque se esperaba uno.1006Abnormal Closure(Reservado) Indica que la conexión se cerró de forma anormal (ej. sin enviar una trama de cierre), típicamente por un fallo de red.1007Invalid frame payload dataDatos de payload inválidos (ej. texto no codificado en UTF-8).1008Policy ViolationEl mensaje viola una política del endpoint y no puede ser procesado.1009Message Too BigEl mensaje recibido es demasiado grande para ser procesado.1011Internal ErrorEl servidor termina la conexión por un error inesperado.1015TLS handshake(Reservado) Falla en el handshake TLS.2.3.6. Ventajas y Desventajas TécnicasVentajas:Comunicación en Tiempo Real de Baja Latencia: Al mantener una conexión TCP única y persistente, WebSocket elimina la sobrecarga y la latencia asociadas con el establecimiento de nuevas conexiones HTTP para cada intercambio, lo que es fundamental para aplicaciones interactivas.51Comunicación Bidireccional (Full-Duplex): A diferencia de HTTP, donde el cliente siempre inicia la comunicación, WebSocket permite que tanto el cliente como el servidor envíen datos de forma proactiva en cualquier momento. Esto es esencial para notificaciones push del servidor al cliente.51Eficiencia de Red: Las tramas de datos de WebSocket tienen una cabecera muy pequeña en comparación con las cabeceras HTTP, lo que reduce significativamente el tráfico de red para aplicaciones con un alto volumen de mensajes pequeños y frecuentes.51Desventajas:Complejidad de Escalabilidad por Estado (Stateful): Las conexiones WebSocket son con estado. El servidor debe mantener información sobre cada conexión activa, lo que consume más memoria y recursos por cliente que en una arquitectura sin estado como REST. Escalar horizontalmente una aplicación WebSocket es más complejo, ya que puede requerir mecanismos para sincronizar el estado entre servidores o asegurar que un cliente siempre se conecte al mismo servidor (sesiones pegajosas).51No es una Solución para CRUD Estándar: WebSocket no fue diseñado para operaciones de solicitud-respuesta simples como las que maneja REST. Implementar una API CRUD completa sobre WebSocket es posible pero innecesariamente complejo en comparación con usar HTTP. No es la herramienta adecuada para exponer recursos de datos de manera estándar.Compatibilidad con Infraestructura Intermedia: Aunque el handshake HTTP ayuda, los proxies, balanceadores de carga y firewalls más antiguos o mal configurados pueden no manejar correctamente las conexiones WebSocket de larga duración, pudiendo cerrarlas prematuramente. Esto requiere una configuración cuidadosa de la infraestructura de red.533. Análisis Comparativo y Criterios de Decisión3.1. Eficiencia en la Transferencia de Datos: La Lucha contra el Over-fetching y el Under-fetchingUno de los criterios más importantes al elegir una arquitectura de API es la eficiencia con la que se transfieren los datos entre el cliente y el servidor. En este ámbito, surgen dos problemas comunes, especialmente en arquitecturas REST: el over-fetching y el under-fetching.29Over-fetching (Sobre-recuperación de datos): Ocurre cuando el cliente descarga más información de la que realmente necesita. Por ejemplo, una aplicación móvil que solo necesita mostrar el nombre de un usuario podría llamar a un endpoint GET /users/{id} que devuelve el objeto de usuario completo, incluyendo dirección, historial de compras y otros datos innecesarios para esa vista específica. Esto desperdicia ancho de banda y aumenta el tiempo de procesamiento en el cliente, lo cual es particularmente crítico en dispositivos móviles con conexiones de red limitadas.30Under-fetching (Infra-recuperación de datos): Es el problema opuesto. Ocurre cuando un endpoint no proporciona toda la información que el cliente necesita, forzándolo a realizar múltiples peticiones adicionales para obtener los datos restantes. Por ejemplo, para mostrar un perfil de usuario junto con sus últimas cinco publicaciones, un cliente REST podría tener que hacer primero una petición a GET /users/{id} y luego otra a GET /users/{id}/posts. Este patrón de múltiples viajes de ida y vuelta (round-trips) incrementa la latencia total y la complejidad en el lado del cliente.31Análisis Comparativo:REST: Es el paradigma más susceptible a estos dos problemas. Debido a su naturaleza orientada a recursos, donde cada endpoint devuelve una estructura de datos fija, es muy difícil diseñar una API que satisfaga las necesidades exactas de todos los clientes (web, móvil, diferentes vistas) sin caer en uno de estos dos extremos.31GraphQL: Ofrece la solución más eficiente y elegante a este problema. Fue diseñado específicamente para eliminar el over-fetching y el under-fetching. Al permitir que el cliente especifique en una única consulta la estructura exacta de los datos que necesita, incluyendo relaciones anidadas, el servidor responde con un payload perfectamente ajustado a los requisitos del cliente en una sola petición. Esto convierte a GraphQL en la opción superior cuando la eficiencia en la obtención de datos es una prioridad.29WebSocket: No aborda directamente este problema. Su enfoque está en el modelo de comunicación (el canal), no en la estructura de los datos que se transmiten. Los mensajes enviados a través de WebSocket pueden contener cualquier tipo de payload, y la responsabilidad de evitar el over/under-fetching recae en el diseño del protocolo de la aplicación que se construye sobre WebSocket.3.2. Modelos de Comunicación: Solicitud-Respuesta vs. Conexión PersistenteLa diferencia fundamental entre estos paradigmas radica en su modelo de comunicación subyacente, lo que determina el tipo de interacción que pueden soportar.Modelo de Solicitud-Respuesta (REST y GraphQL): Ambos operan sobre un modelo de comunicación sin estado donde el cliente inicia una solicitud y el servidor responde. Cada interacción es una transacción discreta e independiente. Una vez que el servidor ha enviado la respuesta, la conexión se cierra (o se devuelve al pool de conexiones en el caso de HTTP Keep-Alive). En este modelo, el servidor no puede enviar datos al cliente de forma proactiva; siempre debe esperar a que el cliente pregunte primero.Modelo de Conexión Persistente (WebSocket): WebSocket establece una conexión con estado, bidireccional y de larga duración. Una vez que se completa el handshake inicial, el canal de comunicación permanece abierto. Esto permite un flujo de datos en ambas direcciones en cualquier momento, lo que significa que el servidor puede "empujar" (push) datos al cliente sin que este los haya solicitado explícitamente.Diagrama 1: Flujo de Comunicación en REST/GraphQL vs. WebSocketEl siguiente diagrama ilustra conceptualmente la diferencia en los flujos de comunicación:Modelo Solicitud-Respuesta (REST / GraphQL)  Cliente                               Servidor

| |
| ----- Petición 1 (ej. GET /user) ---> |
| <---- Respuesta 1 (Datos user) ----- |
| |
| ----- Petición 2 (ej. GET /posts) --> |
| <---- Respuesta 2 (Datos posts) ---- |
| |
|... (El ciclo se repite)... |
En este modelo, cada intercambio es una transacción completa e iniciada por el cliente.Modelo de Conexión Persistente (WebSocket)  Cliente                               Servidor

| |
| --- Handshake HTTP (Upgrade) ------> |
| <--- Respuesta 101 (Switching) ----- |
| |
| <====== Conexión Abierta Bidireccional ======> |
| |
| ------ Mensaje Cliente 1 ----------> |
| <--------- Mensaje Servidor 1 ------ |
| <--------- Mensaje Servidor 2 ------ |
| ------ Mensaje Cliente 2 ----------> |
| |
| <====== Cierre de Conexión ======> |
En este modelo, tras el handshake, ambos pueden enviar mensajes de forma asíncrona a través del canal persistente.3.3. Ecosistema Tecnológico: Frameworks y Librerías de ImplementaciónLa madurez y disponibilidad de herramientas, frameworks y librerías es un factor práctico crucial en la elección de una tecnología. Los tres paradigmas cuentan con ecosistemas robustos en los principales lenguajes de programación.REST: Siendo el más veterano y extendido, REST goza del ecosistema más maduro y diverso. Prácticamente todos los lenguajes y frameworks de backend ofrecen soporte de primera clase para la creación de APIs RESTful, desde microframeworks ligeros hasta soluciones empresariales completas.69GraphQL: A pesar de ser más joven, ha experimentado una adopción masiva y su ecosistema ha crecido exponencialmente. Existen implementaciones de servidor muy potentes y herramientas de cliente sofisticadas que simplifican enormemente la gestión de estado, el caching y la interacción con la API.72WebSocket: El soporte para WebSocket está presente de forma nativa en todos los navegadores modernos a través de la WebSocket API. En el lado del servidor, existen librerías de bajo nivel y soluciones de más alto nivel que abstraen la complejidad de la gestión de conexiones y ofrecen funcionalidades adicionales como fallback a otros transportes (long-polling) o la gestión de "salas" de chat.11La elección entre estas arquitecturas define el "contrato de acoplamiento" entre el cliente y el servidor. No se trata de una elección entre "bueno" y "malo", sino de seleccionar el nivel de interdependencia adecuado para las necesidades del proyecto. REST representa un acoplamiento débil, donde el cliente solo necesita conocer las URIs. Esto es ideal para APIs públicas donde no se tiene control sobre los consumidores.28 GraphQL, por otro lado, crea un acoplamiento más fuerte a través del esquema, lo que a su vez proporciona una flexibilidad inmensa al cliente. Este modelo es perfecto para equipos internos que colaboran estrechamente en un producto.36 Finalmente, WebSocket introduce un acoplamiento de estado (stateful), el más fuerte de los tres. Esta interdependencia es una necesidad para la comunicación en tiempo real, pero conlleva una mayor carga operativa y de escalabilidad. Por lo tanto, la decisión técnica es, en última instancia, una decisión estratégica sobre la relación deseada entre los componentes del sistema.A continuación, se presenta una tabla con algunas de las tecnologías más populares para implementar cada paradigma:ParadigmaLenguaje/EntornoFrameworks / Librerías PopularesRESTNode.jsExpress.js, FastifyPythonDjango REST Framework, Flask, FastAPIJavaSpring Boot, JAX-RSPHPLaravel, SymfonyGraphQLNode.jsApollo Server, GraphQL Yoga, Express-GraphQLPythonGraphene, StrawberryJavaGraphQL-Java, Spring for GraphQL(Como Servicio)Hasura, AWS AppSyncWebSocketNavegadorWebSocket API NativaNode.jsws, Socket.IO.NETASP.NET Core SignalRPythonChannels (Django), FastAPI4. Aplicación Práctica: Casos de Uso y Conclusión4.1. Justificación de Elección en Escenarios RealesLa teoría y el análisis técnico cobran vida cuando se aplican a escenarios de proyectos concretos. A continuación, se describen tres casos de uso distintos, justificando la elección de la arquitectura API más adecuada para cada uno.4.1.1. Caso de Uso 1: API Pública para un BlogDescripción del Proyecto: Se necesita desarrollar una API para un sistema de gestión de contenidos (CMS) de un blog. La API será consumida por una aplicación web principal, pero también estará abierta a terceros para que puedan integrar el contenido del blog en sus propias aplicaciones. Los datos son mayormente de lectura (artículos, autores, categorías) y no cambian con alta frecuencia.Elección Recomendada: RESTJustificación Técnica:Estandarización y Facilidad de Adopción: REST es el estándar de facto para APIs públicas. Su uso de conceptos web universales (URIs, verbos HTTP, códigos de estado) hace que sea extremadamente fácil de entender y consumir por una amplia gama de desarrolladores y herramientas, sin necesidad de librerías especializadas.Cacheabilidad Superior: El contenido de un blog es ideal para el caching. La arquitectura REST se integra perfectamente con los mecanismos de caché de HTTP. Las respuestas de GET /posts/mi-articulo pueden ser cacheadas eficientemente por navegadores, proxies inversos y CDNs, reduciendo drásticamente la carga del servidor y mejorando los tiempos de respuesta para los lectores.16Orientación a Recursos: El modelo de datos de un blog (posts, users, comments) se mapea de forma natural y limpia al modelo de recursos de REST. Las URIs como /posts, /posts/{id} y /users/{id}/posts son intuitivas y autodescriptivas.15Seguridad y Control de Acceso: La granularidad por endpoint facilita la implementación de reglas de acceso. Por ejemplo, se puede permitir el acceso público (lectura) a /posts mientras se restringe el acceso (escritura) a través de POST o PUT solo a usuarios autenticados y con los permisos adecuados.4.1.2. Caso de Uso 2: Panel de Control para una Red Social MóvilDescripción del Proyecto: Se está construyendo la aplicación móvil nativa (iOS y Android) para una nueva red social. La aplicación tiene múltiples vistas complejas: un feed de noticias que muestra publicaciones de diferentes usuarios junto con sus avatares y número de "me gusta"; una pantalla de perfil que muestra los datos del usuario, sus amigos y sus publicaciones; y una sección de notificaciones que agrega diferentes tipos de eventos.Elección Recomendada: GraphQLJustificación Técnica:Eficiencia en Redes Móviles: El principal desafío aquí es la eficiencia de los datos. Las aplicaciones móviles a menudo operan en redes con alta latencia y ancho de banda limitado. GraphQL resuelve el problema del over-fetching y under-fetching al permitir que la aplicación móvil solicite exactamente los datos que necesita para cada vista en una sola petición. Por ejemplo, el feed puede solicitar una lista de posts y, para cada post, solo el title, author.name y author.avatarUrl, evitando descargar el cuerpo completo del post o todos los datos del autor.29Reducción de Round-Trips: En lugar de hacer múltiples peticiones REST (GET /feed, luego para cada post GET /users/{id}), GraphQL puede obtener todos los datos anidados necesarios para una pantalla compleja en un único viaje de ida y vuelta, mejorando significativamente la percepción de velocidad por parte del usuario.31Iteración Rápida del Frontend: Los equipos de frontend pueden experimentar y modificar las vistas de la aplicación sin tener que solicitar constantemente cambios en el backend. Si una nueva vista requiere un campo adicional, simplemente lo añaden a su consulta GraphQL, siempre que esté disponible en el esquema. Esto desacopla el desarrollo del frontend del backend y acelera la iteración.34Esquema como Contrato: El esquema fuertemente tipado de GraphQL sirve como un contrato claro y una fuente de verdad para los equipos de iOS, Android y backend, reduciendo malentendidos y facilitando el desarrollo paralelo.4.1.3. Caso de Uso 3: Aplicación de Chat en Vivo y NotificacionesDescripción del Proyecto: Se debe implementar una funcionalidad de chat en tiempo real dentro de una plataforma de e-learning, donde los estudiantes pueden comunicarse entre ellos y con los instructores. Además, el sistema debe enviar notificaciones instantáneas a los usuarios cuando se publica un nuevo anuncio en un curso.Elección Recomendada: WebSocketJustificación Técnica:Comunicación Bidireccional en Tiempo Real: El requisito fundamental de un chat es la comunicación instantánea y bidireccional. Un usuario necesita recibir mensajes de otros tan pronto como se envían, sin tener que recargar la página o hacer polling. WebSocket es la única tecnología de las tres que proporciona un canal de comunicación full-duplex persistente, permitiendo al servidor "empujar" nuevos mensajes a todos los clientes conectados en una sala de chat de forma instantánea.12Baja Latencia y Eficiencia: Para una conversación fluida, la latencia debe ser mínima. El protocolo WebSocket, con su conexión TCP persistente y tramas de datos de baja sobrecarga, es mucho más eficiente para el envío de mensajes pequeños y frecuentes que el modelo de solicitud-respuesta de HTTP sobre el que operan REST y GraphQL.51Gestión de Estado de Presencia: En una aplicación de chat, es útil saber qué usuarios están "en línea". La naturaleza con estado de las conexiones WebSocket facilita la implementación de sistemas de presencia. El servidor mantiene un registro de las conexiones activas y puede notificar a los clientes cuando un usuario se conecta o se desconecta.Notificaciones Push: De manera similar al chat, las notificaciones de nuevos anuncios requieren que el servidor inicie la comunicación. WebSocket es ideal para este propósito, permitiendo que el servidor envíe el evento de notificación a los clientes relevantes en el momento en que ocurre.4.2. Conclusión Final: Síntesis y Recomendaciones ProfesionalesEl análisis detallado de REST, GraphQL y WebSocket revela que no existe una solución universalmente superior. La elección de la arquitectura de comunicación no debe basarse en la popularidad de una tecnología, sino en un análisis riguroso de los requisitos específicos del proyecto. Cada paradigma ofrece un conjunto único de herramientas y filosofías diseñado para resolver un tipo diferente de problema.REST sigue siendo la opción predilecta para APIs públicas y servicios orientados a recursos. Su simplicidad, su adhesión a los estándares web probados y su robusto soporte para el caching lo convierten en una opción fiable, escalable y fácil de adoptar para exponer datos de manera estandarizada. Es la elección correcta cuando la previsibilidad y la interoperabilidad son más importantes que la flexibilidad de las consultas.GraphQL brilla en el desarrollo de aplicaciones con clientes complejos y diversos, como las aplicaciones móviles y las SPAs. Su capacidad para permitir que el cliente dicte la forma de los datos resuelve de manera concluyente los problemas de eficiencia de REST (over/under-fetching), reduce la latencia y acelera drásticamente los ciclos de desarrollo del frontend. Es la herramienta estratégica cuando la eficiencia de la obtención de datos y la agilidad del desarrollo del producto son las máximas prioridades.WebSocket es la solución indispensable para cualquier funcionalidad que requiera comunicación bidireccional y en tiempo real. Para aplicaciones como chats, juegos multijugador, dashboards con datos en vivo o sistemas de notificaciones instantáneas, su modelo de canal persistente y de baja latencia es simplemente insustituible por los paradigmas de solicitud-respuesta.Es importante destacar que estas arquitecturas no son mutuamente excluyentes. Un sistema complejo y moderno a menudo se beneficia de un enfoque híbrido. Una plataforma puede utilizar una API REST para sus datos públicos, una API GraphQL para su aplicación móvil principal y un servidor WebSocket para su funcionalidad de chat y notificaciones. La clave del éxito en la arquitectura de software moderna reside en comprender las fortalezas y debilidades de cada herramienta y aplicarla juiciosamente donde aporte el mayor valor.5. Referencias y Fuentes5 - https://www.mailclick.com.mx/arquitectura-web/2 - https://kinsta.com/es/blog/arquitectura-aplicaciones-web/1 - https://cloud.google.com/learn/what-is-cloud-architecture?hl=es-4193 - https://www.godaddy.com/resources/es/crearweb/que-es-la-arquitectura-de-la-informacion-web4 - https://onenine.com/es/website-information-architecture/6 - https://www.shoutoutuk.org/2024/10/24/the-evolution-of-apis-from-traditional-to-modern-solutions/7 - https://hygraph.com/blog/evolution-of-apis77 - https://developer.mozilla.org/es/docs/Learn_web_development/Extensions/Client-side_APIs/Introduction8 - https://strapi.io/blog/evolution-of-apis-from-pre-rest-era-to-modern-restful-and-beyond9 - https://aws.amazon.com/es/what-is/api/18 - https://docs.aws.amazon.com/es_es/appsync/latest/devguide/what-is-rest.html19 - https://aws.amazon.com/es/what-is/restful-api/15 - https://api7.ai/es/learning-center/api-101/restful-api-best-practices13 - https://medium.com/@diego.coder/introducci%C3%B3n-a-las-apis-rest-6b3ad900acc916 - https://www.ibm.com/es-es/think/topics/rest-apis17 - https://en.wikipedia.org/wiki/REST20 - https://dev.to/miltondiazco/entendiendo-las-apis-restful-y-el-protocolo-http-44a614 - https://www.redhat.com/es/topics/api/what-is-a-rest-api22 - https://www.mentorestech.com/resource-blog-content/verbos-http-en-apis-rest-que-son-y-como-usarlos-correctamente23 - https://restfulapi.net/http-methods/78 - https://codigofacilito.com/articulos/verbos-http-rest21 - https://vicente-aguilera-perez.medium.com/las-10-mejores-pr%C3%A1cticas-para-nombrar-api-rest-endpoints-48b8bcbd139724 - https://payloadcms.com/docs/rest-api/overview27 - https://www.q2bstudio.com/nuestro-blog/163/apis-rest-vs-graphql-desarrollo-aplicaciones25 - https://www.dotcom-monitor.com/wiki/es/knowledge-base/http-status-codes/26 - https://developer.mozilla.org/es/docs/Web/HTTP/Reference/Status79 - https://learn.microsoft.com/es-es/rest/api/storageservices/common-rest-api-error-codes80 - https://developers.google.com/search/apis/indexing-api/v3/core-errors?hl=es-41981 - https://kinsta.com/es/blog/codigos-de-estado-de-http/82 - https://www.ibm.com/docs/es/bpm/8.5.6?topic=apis-status-codes27 - https://www.q2bstudio.com/nuestro-blog/163/apis-rest-vs-graphql-desarrollo-aplicaciones28 - https://desarrolloweb.com/articulos/ventajas-inconvenientes-apirest-desarrollo.html19 - https://aws.amazon.com/es/what-is/restful-api/29 - https://www.ibm.com/think/topics/graphql-vs-rest-api66 - https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching67 - https://www.geeksforgeeks.org/graphql/what-are-over-fetching-and-under-fetching/30 - https://www.programmersinc.com/over-fetching-and-under-fetching-rest-apis-exhaustion-signs/31 - https://www.howtographql.com/basics/1-graphql-is-the-better-rest/68 - https://nordicapis.com/how-to-avoid-overfetching-and-underfetching/10 - https://www.f5.com/es_es/glossary/graphql46 - https://www.ibm.com/es-es/think/topics/graphql33 - https://www.paradigmadigital.com/dev/graphql-todos-uno-uno-todos/32 - https://aws.amazon.com/es/compare/the-difference-between-graphql-and-rest/36 - https://graphql.org/learn/schema/34 - https://graphql.org/35 - https://lab.wallarm.com/what/protocolo-graphql/?lang=es37 - https://medium.com/@diego.coder/introducci%C3%B3n-a-graphql-d596b77719e339 - https://www.escuelafrontend.com/guia-practica-de-graphql40 - https://zerodayhacker.com/graphql-queries-mutations-and-subscriptions/41 - https://graphql.org/learn/mutations/83 - https://graphql.org/learn/queries/42 - https://graphql.org/learn/subscriptions/38 - https://graphql.org/learn/serving-over-http/43 - https://medium.com/@mrando-via/api-rest-y-graphql-2c95df17dc6044 - https://docs.github.com/es/graphql/guides/forming-calls-with-graphql45 - https://www.browserstack.com/guide/graphql-errors47 - https://daily.dev/blog/graphql-errors-understanding-the-basics48 - https://docs.aws.amazon.com/es_es/appsync/latest/devguide/why-use-graphql.html11 - https://developer.mozilla.org/es/docs/Web/API/WebSockets_API12 - https://www.ionos.com/es-us/digitalguide/paginas-web/desarrollo-web/que-es-websocket/49 - https://medium.com/@diego.coder/introducci%C3%B3n-a-los-websockets-92544b1c6a8a50 - https://es.wikipedia.org/wiki/WebSocket53 - https://lab.wallarm.com/what/protocolo-websocket/?lang=es52 - https://www.rfc-editor.org/rfc/rfc6455.html65 - https://www.tech-invite.com/y60/tinv-ietf-rfc-6455.html54 - https://datatracker.ietf.org/doc/html/rfc645555 - https://makeitrealcamp.gitbook.io/guias-de-make-it-real/express.js-ii/web-sockets56 - https://developer.mozilla.org/es/docs/Web/API/WebSocket58 - https://noio-ws.readthedocs.io/en/latest/overview_of_websockets.html59 - https://cse312.com/static_files/slides/3_3_WebSocket_Handshake.pdf57 - https://medium.com/@moali314/mastering-websockets-410403eba4a061 - https://dev.to/jaypmedia/websockets-explained-under-10-minutes-with-visuals-3ocl60 - https://www.nilebits.com/blog/2023/07/websocket-handshaking-explained-understanding-the-key-to-real-time-communication/62 - https://websocket.org/reference/close-codes/84 - https://developer.mozilla.org/es/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications63 - https://docs.aws.amazon.com/es_es/iot-wireless/latest/developerguide/network-analyer-messages-status.html51 - https://lab.wallarm.com/what/websocket-frente-a-http/?lang=es64 - https://apidog.com/es/blog/webhook-vs-websocket-3/85 - https://blog.logto.io/es/http-vs-websocket69 - https://www.browserstack.com/guide/top-python-rest-api-frameworks70 - https://www.moesif.com/blog/api-product-management/api-analytics/10-Most-Popular-Frameworks-For-Building-RESTful-APIs/71 - https://www.carmatec.com/es_mx/blog/top-10-php-rest-api-frameworks/72 - https://dzone.com/articles/graphql-frameworks73 - https://www.paradigmadigital.com/dev/graphql-todos-uno-uno-todos-22/74 - https://apidog.com/es/blog/best-graphql-tools-3/75 - https://appmaster.io/es/blog/marcos-y-bibliotecas-de-websocket76 - https://ably.com/blog/websocket-libraries-for-node16 - https://www.ibm.com/es-es/think/topics/rest-apis22 - https://www.mentorestech.com/resource-blog-content/verbos-http-en-apis-rest-que-son-y-como-usarlos-correctamente13 - https://medium.com/@diego.coder/introducci%C3%B3n-a-las-apis-rest-6b3ad900acc910 - https://www.f5.com/es_es/glossary/graphql38 - https://graphql.org/learn/serving-over-http/40 - https://zerodayhacker.com/graphql-queries-mutations-and-subscriptions/38 - https://graphql.org/learn/serving-over-http/45 - https://www.browserstack.com/guide/graphql-errors46 - https://www.ibm.com/es-es/think/topics/graphql51 - https://lab.wallarm.com/what/websocket-frente-a-http/?lang=es52 - https://www.rfc-editor.org/rfc/rfc6455.html56 - https://developer.mozilla.org/es/docs/Web/API/WebSocket57 - https://medium.com/@moali314/mastering-websockets-410403eba4a062 - https://websocket.org/reference/close-codes/51 - https://lab.wallarm.com/what/websocket-frente-a-http/?lang=es
